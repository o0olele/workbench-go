package statetree

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"
)

// ============================================================================
// 1. Data Definitions
// ============================================================================

type StateType string

const (
	StateLeaf  StateType = "Leaf"
	StateGroup StateType = "Group"
	StateRoot  StateType = "Root"
)

type TriggerType string

const (
	TriggerOnStateCompleted TriggerType = "OnStateCompleted"
	TriggerOnStateSucceeded TriggerType = "OnStateSucceeded"
	TriggerOnStateFailed    TriggerType = "OnStateFailed"
	TriggerOnTick           TriggerType = "OnTick"
	TriggerOnEvent          TriggerType = "OnEvent"
)

// Transition defines a state transition
type Transition struct {
	TargetState string
	Trigger     TriggerType
	Condition   string // Go code string, e.g. "ctx.Data.HasEnemy()"
}

// Task defines a task execution
type Task struct {
	Name string // e.g. "MoveToTask"
}

// StateNode represents a state in the tree
type StateNode struct {
	Name           string
	Type           StateType
	Description    string
	Parent         *StateNode
	Children       []*StateNode
	EnterCondition string       // Code to check before entering (SelectState logic)
	Tasks          []Task       // Tasks to run in this state
	Transitions    []Transition // Transitions out of this state
}

// StateTreeDefinition is the root object for generation
type StateTreeDefinition struct {
	PackageName string
	StructName  string
	ContextType string // The type name of the context data, e.g. "*MyContext"
	Root        *StateNode
}

// ============================================================================
// 2. Generator Logic
// ============================================================================

type Generator struct {
	Def *StateTreeDefinition
}

func NewGenerator(def *StateTreeDefinition) *Generator {
	return &Generator{Def: def}
}

// FlattenStates returns a list of all states including Root and Groups
func (g *Generator) FlattenStates() []*StateNode {
	var states []*StateNode
	var traverse func(*StateNode)
	traverse = func(node *StateNode) {
		states = append(states, node)
		for _, child := range node.Children {
			traverse(child)
		}
	}
	traverse(g.Def.Root)
	return states
}

// GetPath returns the path from root to node
func (g *Generator) GetPath(node *StateNode) []*StateNode {
	var path []*StateNode
	curr := node
	for curr != nil {
		path = append([]*StateNode{curr}, path...)
		curr = curr.Parent
	}
	return path
}

// FindLCA finds the Lowest Common Ancestor of two nodes
func (g *Generator) FindLCA(a, b *StateNode) *StateNode {
	pathA := g.GetPath(a)
	pathB := g.GetPath(b)

	var lca *StateNode
	for i := 0; i < len(pathA) && i < len(pathB); i++ {
		if pathA[i] == pathB[i] {
			lca = pathA[i]
		} else {
			break
		}
	}
	return lca
}

// Generate generates the Go source code
func (g *Generator) Generate() ([]byte, error) {
	tmpl, err := template.New("statetree").Funcs(template.FuncMap{
		"ToUpper": strings.ToUpper,
		"IsGroup": func(n *StateNode) bool { return n.Type == StateGroup || n.Type == StateRoot },
	}).Parse(stateTreeTemplate)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	if err = tmpl.Execute(&buf, g); err != nil {
		return nil, err
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code on error for debugging, wrapped in error
		return buf.Bytes(), fmt.Errorf("format error: %v", err)
	}
	return formatted, nil
}

// ============================================================================
// 3. Templates
// ============================================================================

const stateTreeTemplate = `
// Code generated by go_statetree_gen. DO NOT EDIT.
package {{.Def.PackageName}}

import (
	"fmt"
)

// State Enum
type EState int

const (
	State_Unset EState = iota
{{- range .FlattenStates }}
	State_{{ .Name }}
{{- end }}
)

func (s EState) String() string {
	switch s {
	case State_Unset: return "Unset"
{{- range .FlattenStates }}
	case State_{{ .Name }}: return "{{ .Name }}"
{{- end }}
	default: return fmt.Sprintf("Unknown(%d)", s)
	}
}

// {{.Def.StructName}} StateTree
type {{.Def.StructName}} struct {
	CurrentState EState
	Context      {{.Def.ContextType}}
    
    // Internal flags
    hasTransitioned bool
}

func New{{.Def.StructName}}(ctx {{.Def.ContextType}}) *{{.Def.StructName}} {
	return &{{.Def.StructName}}{
		CurrentState: State_Unset,
		Context:      ctx,
	}
}

// Start initializes the tree
func (st *{{.Def.StructName}}) Start() {
    st.EnterState(State_{{.Def.Root.Name}})
}

// Tick updates the state tree
func (st *{{.Def.StructName}}) Tick(dt float64) {
    st.hasTransitioned = false

	// Always tick Root first (if it has logic)
	st.Tick_State_{{.Def.Root.Name}}(dt)
    if st.hasTransitioned { return }

	switch st.CurrentState {
{{- range .FlattenStates }}
    {{- if ne .Type "Root" }}
	case State_{{ .Name }}:
		st.Tick_State_{{ .Name }}(dt)
    {{- end }}
{{- end }}
	}
}

// Transition Helper
func (st *{{.Def.StructName}}) EnterState(newState EState) {
    oldState := st.CurrentState
    st.CurrentState = newState
    st.hasTransitioned = true
    
    lca := st.FindLCA(oldState, newState)
    
    // Exit sequence (Bottom-Up to LCA child)
    curr := oldState
    for curr != State_Unset && curr != lca {
        st.Exit_State_Dispatch(curr)
        curr = st.GetParentState(curr)
    }
    
    // Enter sequence (Top-Down from LCA child)
    // We need to collect the path first
    var path []EState
    curr = newState
    for curr != State_Unset && curr != lca {
        path = append(path, curr)
        curr = st.GetParentState(curr)
    }
    // Reverse path
    for i := len(path)-1; i >= 0; i-- {
        st.Enter_State_Dispatch(path[i])
    }
}

func (st *{{.Def.StructName}}) FindLCA(a, b EState) EState {
    if a == b { return a }
    if a == State_Unset { return State_Unset } 
    
    pathA := make(map[EState]bool)
    curr := a
    for curr != State_Unset {
        pathA[curr] = true
        curr = st.GetParentState(curr)
    }
    
    curr = b
    for curr != State_Unset {
        if pathA[curr] {
            return curr
        }
        curr = st.GetParentState(curr)
    }
    return State_Unset
}

func (st *{{.Def.StructName}}) GetParentState(s EState) EState {
    switch s {
{{- range .FlattenStates }}
    {{- if .Parent }}
    case State_{{ .Name }}: return State_{{ .Parent.Name }}
    {{- else }}
    case State_{{ .Name }}: return State_Unset
    {{- end }}
{{- end }}
    default: return State_Unset
    }
}

func (st *{{.Def.StructName}}) Exit_State_Dispatch(s EState) {
    switch s {
{{- range .FlattenStates }}
    case State_{{ .Name }}: st.Exit_State_{{ .Name }}()
{{- end }}
    }
}

func (st *{{.Def.StructName}}) Enter_State_Dispatch(s EState) {
    switch s {
{{- range .FlattenStates }}
    case State_{{ .Name }}: st.Enter_State_{{ .Name }}()
{{- end }}
    }
}

// ============================================================================
// State Logic Functions (Hierarchical)
// ============================================================================

{{- range .FlattenStates }}

// --- State: {{ .Name }} ({{ .Type }}) ---

func (st *{{$.Def.StructName}}) Tick_State_{{ .Name }}(dt float64) {
    // 1. Call Parent Tick (Hierarchical Call)
{{- if .Parent }}
    st.Tick_State_{{ .Parent.Name }}(dt)
    if st.hasTransitioned { return }
{{- end }}

    // 2. Transitions (Check conditions)
{{- range .Transitions }}
    {{- if eq .Trigger "OnTick" }}
    if {{ .Condition }} {
        st.EnterState(State_{{ .TargetState }})
        return
    }
    {{- end }}
{{- end }}

    // 3. Tasks
{{- range .Tasks }}
    // Task: {{ .Name }}
    // st.Context.{{ .Name }}_Tick(dt) 
{{- end }}
}

func (st *{{$.Def.StructName}}) Enter_State_{{ .Name }}() {
    // fmt.Println("Enter: {{ .Name }}")
}

func (st *{{$.Def.StructName}}) Exit_State_{{ .Name }}() {
    // fmt.Println("Exit: {{ .Name }}")
}

{{- end }}
`
