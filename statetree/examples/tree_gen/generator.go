package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"text/template"
)

// GeneratorConfig holds the configuration for generating the state tree.
type GeneratorConfig struct {
	PackageName string
	TreeName    string
	States      []GenStateDef
}

type GenStateDef struct {
	ID                string
	Parent            string
	Tasks             []GenTaskDef
	Transitions       []GenTransitionDef
	EnterConditions   []string // Code for conditions, e.g. "&enemyNearbyCondition{}"
	SelectionBehavior string   // "SelectionEnterState", "SelectionChildrenInOrder", "SelectionChildrenRandom"
	Children          []string // Child State IDs
}

type GenTaskDef struct {
	InstanceCode string // e.g. "&patrolTask{}"
}

type GenTransitionDef struct {
	Target     string
	Trigger    string   // "TriggerOnTick", "TriggerOnEvent", etc.
	Priority   string   // "PriorityNormal", etc.
	Conditions []string // Code for conditions
	EventName  string
}

// Generate produces the Go source code for the state tree.
func Generate(config GeneratorConfig) error {
	funcMap := template.FuncMap{
		"quote": func(s string) string {
			return fmt.Sprintf("%q", s)
		},
		"sub": func(a, b, c int) int {
			return a - b - c
		},
	}

	tmpl, err := template.New("statetree").Funcs(funcMap).Parse(treeTemplate)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, config); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	// Format the source code
	src, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, print the raw code for debugging
		fmt.Println(buf.String())
		return fmt.Errorf("formatting source: %w", err)
	}

	return os.WriteFile("generated_tree.go", src, 0644)
}

const treeTemplate = `
// Code generated by statetree generator. DO NOT EDIT.

package {{.PackageName}}

import (
	"fmt"
)

// ============================================================================
// Generated Tree: {{.TreeName}}
// ============================================================================

type {{.TreeName}} struct {
	Context            *Context
	ActiveStates       []StateID
	CurrentState       StateID
	NextTransition     *Transition
	PendingEvent       string
	LastCompletedState StateID
	LastStatus         Status
	Logger             Logger
	
	// Task Instances
	{{- range .States}}
	{{- $stateID := .ID }}
	{{- range $i, $task := .Tasks}}
	Task_{{$stateID}}_{{$i}} Task
	{{- end}}
	{{- end}}

	// Condition Instances (Not strictly needed if stateless, but good for consistency)
}

func New{{.TreeName}}() *{{.TreeName}} {
	t := &{{.TreeName}}{
		ActiveStates: make([]StateID, 0, 8),
		Logger:       &DefaultLogger{},
	}
	t.Context = NewContext()
    t.Context.OnSendEvent = t.SendEvent
	
	// Initialize Tasks
	{{- range .States}}
	{{- $stateID := .ID }}
	{{- range $i, $task := .Tasks}}
	t.Task_{{$stateID}}_{{$i}} = {{.InstanceCode}}
	{{- end}}
	{{- end}}
	
	return t
}

func (t *{{.TreeName}}) SetLogger(l Logger) {
	t.Logger = l
}

func (t *{{.TreeName}}) SendEvent(name string) {
	t.PendingEvent = name
}

func (t *{{.TreeName}}) Tick(deltaTime float64) {
	t.Logger.Printf("\n--- Tick (dt=%.3f) ---", deltaTime)
	t.tickTasks(deltaTime)
	t.tickTransitions(deltaTime)
}

func (t *{{.TreeName}}) tickTasks(deltaTime float64) {
	t.Logger.Printf("• Ticking Tasks")
	
	shouldContinue := true
	for _, stateID := range t.ActiveStates {
		if !shouldContinue {
			break
		}
		
		switch stateID {
		{{- range .States}}
		{{- $stateID := .ID }}
		case "{{.ID}}":
			{{- if .Tasks}}
			t.Logger.Printf("  State [%s] ticking tasks", stateID)
			{{- range $i, $task := .Tasks}}
			if shouldContinue {
				status := t.Task_{{$stateID}}_{{$i}}.Tick(t.Context, deltaTime)
				if status == StatusFailed {
					shouldContinue = false
					t.LastStatus = StatusFailed
				} else if status == StatusSucceeded {
                    // Logic for task success? 
                    // main.go only marks state success if ALL tasks are done or something?
                    // main.go: activeState.taskStatus[j] = status
                    // And check for empty states.
                    // Simplified: just update LastStatus
                    t.LastStatus = status
                } else {
                    t.LastStatus = StatusRunning
                }
			}
			{{- end}}
			{{- else}}
			// No tasks
			{{- end}}
		{{- end}}
		}
	}
    
    // Check for empty states (instant success)
	if len(t.ActiveStates) > 0 {
		leafState := t.ActiveStates[len(t.ActiveStates)-1]
        // In main.go, it checks if len(tasks) == 0.
        // We can generate this check.
        switch leafState {
        {{- range .States}}
        case "{{.ID}}":
            {{- if not .Tasks}}
            t.LastStatus = StatusSucceeded
            t.LastCompletedState = "{{.ID}}"
            t.Logger.Printf("  Empty state [%s] marked as Succeeded", leafState)
            {{- end}}
        {{- end}}
        }
	}
}

func (t *{{.TreeName}}) tickTransitions(deltaTime float64) {
	t.Logger.Printf("• Checking Transitions")
	maxIterations := 10
	for i := 0; i < maxIterations; i++ {
		if !t.triggerTransitions() {
			break
		}
		
		if t.NextTransition != nil {
			target := t.NextTransition.target
			t.Logger.Printf("  → Transition to [%s]", target)
			
			// Store old states for LCA calculation
			oldActiveStates := make([]StateID, len(t.ActiveStates))
			copy(oldActiveStates, t.ActiveStates)
			
			if t.selectState(target) {
				// Calculate LCA index
				lcaIndex := 0
				lenOld := len(oldActiveStates)
				lenNew := len(t.ActiveStates)
				limit := lenOld
				if lenNew < limit { limit = lenNew }
				
				for i := 0; i < limit; i++ {
					if oldActiveStates[i] != t.ActiveStates[i] {
						break
					}
					lcaIndex = i + 1
				}
				
				// t.Logger.Printf("• Changing state (LCA Index: %d)", lcaIndex)

				// Exit old states (Reverse order, down to LCA)
				for i := lenOld - 1; i >= lcaIndex; i-- {
					t.exitNode(oldActiveStates[i])
				}
				
				// Enter new states (Forward order, from LCA)
				for i := lcaIndex; i < lenNew; i++ {
					t.enterNode(t.ActiveStates[i])
				}
			}
			t.NextTransition = nil
			t.LastCompletedState = StateUnset
			t.LastStatus = StatusRunning
		}
	}
	t.PendingEvent = ""
}

func (t *{{.TreeName}}) triggerTransitions() bool {
	// Iterate from leaf to root
	for i := len(t.ActiveStates) - 1; i >= 0; i-- {
		stateID := t.ActiveStates[i]
		
		// Generated transition checks
		switch stateID {
		{{- range .States}}
		case "{{.ID}}":
			// State: {{.ID}}
			{{- if .Transitions}}
			{{- range .Transitions}}
			if t.checkTransition_{{.Target}}() { return true }
			{{- end}}
			{{- end}}
		{{- end}}
		}
	}
	return false
}

// Transition Check Methods
{{- range .States}}
{{- $stateID := .ID }}
{{- range .Transitions}}
func (t *{{$.TreeName}}) checkTransition_{{.Target}}() bool {
    // Trigger: {{.Trigger}}
    {{- if eq .Trigger "TriggerOnEvent"}}
    if t.PendingEvent != {{quote .EventName}} { return false }
    {{- else if eq .Trigger "TriggerOnStateCompleted"}}
    if t.LastCompletedState != "{{$stateID}}" { return false }
    {{- else if eq .Trigger "TriggerOnStateSucceeded"}}
    if t.LastCompletedState != "{{$stateID}}" || t.LastStatus != StatusSucceeded { return false }
    {{- else if eq .Trigger "TriggerOnStateFailed"}}
    if t.LastCompletedState != "{{$stateID}}" || t.LastStatus != StatusFailed { return false }
    {{- end}}

    // Conditions
    {{- range .Conditions}}
    if !({{.}}).Test(t.Context) { return false }
    {{- end}}

    // Can Select Target
    if !t.canSelectState("{{.Target}}") { return false }

    // Set Transition
    t.NextTransition = &Transition{
        target: "{{.Target}}",
        priority: {{.Priority}},
    }
    return true
}
{{- end}}
{{- end}}

func (t *{{.TreeName}}) canSelectState(target StateID) bool {
    switch target {
    {{- range .States}}
    case "{{.ID}}":
        {{- if .EnterConditions}}
        {{- range .EnterConditions}}
        if !({{.}}).Test(t.Context) { return false }
        {{- end}}
        {{- end}}
        return true
    {{- end}}
    }
    return false
}

func (t *{{.TreeName}}) selectState(target StateID) bool {
    t.Logger.Printf("  Selecting state [%s]", target)
    t.ActiveStates = t.ActiveStates[:0]
    
    // Build path (hardcoded per target)
    switch target {
    {{- range .States}}
    case "{{.ID}}":
        if !t.addToPath_{{.ID}}() { return false }
        
        // Child Selection
        {{- if .Children}}
        // Behavior: {{.SelectionBehavior}}
        {{- if eq .SelectionBehavior "SelectionChildrenInOrder"}}
        {{- range .Children}}
        if t.canSelectState("{{.}}") && t.selectState("{{.}}") { return true }
        {{- end}}
        {{- end}}
        return false
        {{- end}}
    {{- end}}
    }
    
    t.CurrentState = target
    return true
}

// Path Selection Methods
{{- range .States}}
{{- $stateID := .ID }}
func (t *{{$.TreeName}}) addToPath_{{.ID}}() bool {
    // Parent
    {{- if ne .Parent ""}}
    if !t.addToPath_{{.Parent}}() { return false }
    {{- end}}
    
    // Self
    // Check Enter Conditions
    {{- range .EnterConditions}}
    if !({{.}}).Test(t.Context) { 
        t.Logger.Printf("    Enter conditions failed for [%s]", "{{$stateID}}")
        return false 
    }
    {{- end}}
    
    t.ActiveStates = append(t.ActiveStates, "{{.ID}}")
    return true
}
{{- end}}

func (t *{{.TreeName}}) Start(startState StateID) error {
	t.Logger.Printf("=== StateTree Starting ===")
	if !t.selectState(startState) {
		return fmt.Errorf("failed to select start state %s", startState)
	}
	// Enter all initial states
	for _, id := range t.ActiveStates {
		t.enterNode(id)
	}
	return nil
}

func (t *{{.TreeName}}) Stop() {
	t.Logger.Printf("=== StateTree Stopping ===")
	for i := len(t.ActiveStates) - 1; i >= 0; i-- {
		t.exitNode(t.ActiveStates[i])
	}
	t.ActiveStates = t.ActiveStates[:0]
}

func (t *{{.TreeName}}) enterNode(stateID StateID) {
	t.Logger.Printf("• Entering state [%s]", stateID)
	switch stateID {
	{{- range .States}}
	{{- $stateID := .ID }}
	case "{{.ID}}":
		{{- range $i, $task := .Tasks}}
		t.Task_{{$stateID}}_{{$i}}.EnterState(t.Context)
		{{- end}}
	{{- end}}
	}
}

func (t *{{.TreeName}}) exitNode(stateID StateID) {
	t.Logger.Printf("  Exiting state [%s]", stateID)
	switch stateID {
	{{- range .States}}
	{{- $stateID := .ID }}
	case "{{.ID}}":
		{{- $tasksLen := len .Tasks }}
		{{- range $i, $task := .Tasks}}
		{{- $revIndex := sub $tasksLen $i 1 }}
		t.Task_{{$stateID}}_{{$revIndex}}.ExitState(t.Context)
		{{- end}}
	{{- end}}
	}
}
`
