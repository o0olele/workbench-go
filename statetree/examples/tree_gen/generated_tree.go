// Code generated by statetree generator. DO NOT EDIT.

package main

import (
	"fmt"
)

// ============================================================================
// Generated Tree: MonsterTree
// ============================================================================

type MonsterTree struct {
	Context            *Context
	ActiveStates       []StateID
	CurrentState       StateID
	NextTransition     *Transition
	PendingEvent       string
	LastCompletedState StateID
	LastStatus         Status
	Logger             Logger

	// Task Instances
	Task_Idle_0   Task
	Task_Patrol_0 Task

	// Condition Instances (Not strictly needed if stateless, but good for consistency)
}

func NewMonsterTree() *MonsterTree {
	t := &MonsterTree{
		ActiveStates: make([]StateID, 0, 8),
		Logger:       &DefaultLogger{},
	}
	t.Context = NewContext()
	t.Context.OnSendEvent = t.SendEvent

	// Initialize Tasks
	t.Task_Idle_0 = &idleTask{}
	t.Task_Patrol_0 = &patrolTask{}

	return t
}

func (t *MonsterTree) SetLogger(l Logger) {
	t.Logger = l
}

func (t *MonsterTree) SendEvent(name string) {
	t.PendingEvent = name
}

func (t *MonsterTree) Tick(deltaTime float64) {
	t.Logger.Printf("\n--- Tick (dt=%.3f) ---", deltaTime)
	t.tickTasks(deltaTime)
	t.tickTransitions(deltaTime)
}

func (t *MonsterTree) tickTasks(deltaTime float64) {
	t.Logger.Printf("• Ticking Tasks")

	shouldContinue := true
	for _, stateID := range t.ActiveStates {
		if !shouldContinue {
			break
		}

		switch stateID {
		case "Root":
			// No tasks
		case "Idle":
			t.Logger.Printf("  State [%s] ticking tasks", stateID)
			if shouldContinue {
				status := t.Task_Idle_0.Tick(t.Context, deltaTime)
				if status == StatusFailed {
					shouldContinue = false
					t.LastStatus = StatusFailed
				} else if status == StatusSucceeded {
					// Logic for task success?
					// main.go only marks state success if ALL tasks are done or something?
					// main.go: activeState.taskStatus[j] = status
					// And check for empty states.
					// Simplified: just update LastStatus
					t.LastStatus = status
				} else {
					t.LastStatus = StatusRunning
				}
			}
		case "Patrol":
			t.Logger.Printf("  State [%s] ticking tasks", stateID)
			if shouldContinue {
				status := t.Task_Patrol_0.Tick(t.Context, deltaTime)
				if status == StatusFailed {
					shouldContinue = false
					t.LastStatus = StatusFailed
				} else if status == StatusSucceeded {
					// Logic for task success?
					// main.go only marks state success if ALL tasks are done or something?
					// main.go: activeState.taskStatus[j] = status
					// And check for empty states.
					// Simplified: just update LastStatus
					t.LastStatus = status
				} else {
					t.LastStatus = StatusRunning
				}
			}
		case "Chase":
			// No tasks
		}
	}

	// Check for empty states (instant success)
	if len(t.ActiveStates) > 0 {
		leafState := t.ActiveStates[len(t.ActiveStates)-1]
		// In main.go, it checks if len(tasks) == 0.
		// We can generate this check.
		switch leafState {
		case "Root":
			t.LastStatus = StatusSucceeded
			t.LastCompletedState = "Root"
			t.Logger.Printf("  Empty state [%s] marked as Succeeded", leafState)
		case "Idle":
		case "Patrol":
		case "Chase":
			t.LastStatus = StatusSucceeded
			t.LastCompletedState = "Chase"
			t.Logger.Printf("  Empty state [%s] marked as Succeeded", leafState)
		}
	}
}

func (t *MonsterTree) tickTransitions(deltaTime float64) {
	t.Logger.Printf("• Checking Transitions")
	maxIterations := 10
	for i := 0; i < maxIterations; i++ {
		if !t.triggerTransitions() {
			break
		}

		if t.NextTransition != nil {
			target := t.NextTransition.target
			t.Logger.Printf("  → Transition to [%s]", target)

			// Store old states for LCA calculation
			oldActiveStates := make([]StateID, len(t.ActiveStates))
			copy(oldActiveStates, t.ActiveStates)

			if t.selectState(target) {
				// Calculate LCA index
				lcaIndex := 0
				lenOld := len(oldActiveStates)
				lenNew := len(t.ActiveStates)
				limit := lenOld
				if lenNew < limit {
					limit = lenNew
				}

				for i := 0; i < limit; i++ {
					if oldActiveStates[i] != t.ActiveStates[i] {
						break
					}
					lcaIndex = i + 1
				}

				// t.Logger.Printf("• Changing state (LCA Index: %d)", lcaIndex)

				// Exit old states (Reverse order, down to LCA)
				for i := lenOld - 1; i >= lcaIndex; i-- {
					t.exitNode(oldActiveStates[i])
				}

				// Enter new states (Forward order, from LCA)
				for i := lcaIndex; i < lenNew; i++ {
					t.enterNode(t.ActiveStates[i])
				}
			}
			t.NextTransition = nil
			t.LastCompletedState = StateUnset
			t.LastStatus = StatusRunning
		}
	}
	t.PendingEvent = ""
}

func (t *MonsterTree) triggerTransitions() bool {
	// Iterate from leaf to root
	for i := len(t.ActiveStates) - 1; i >= 0; i-- {
		stateID := t.ActiveStates[i]

		// Generated transition checks
		switch stateID {
		case "Root":
			// State: Root
		case "Idle":
			// State: Idle
			if t.checkTransition_Patrol() {
				return true
			}
		case "Patrol":
			// State: Patrol
			if t.checkTransition_Idle() {
				return true
			}
			if t.checkTransition_Chase() {
				return true
			}
		case "Chase":
			// State: Chase
		}
	}
	return false
}

// Transition Check Methods
func (t *MonsterTree) checkTransition_Patrol() bool {
	// Trigger: TriggerOnTick

	// Conditions

	// Can Select Target
	if !t.canSelectState("Patrol") {
		return false
	}

	// Set Transition
	t.NextTransition = &Transition{
		target:   "Patrol",
		priority: PriorityNormal,
	}
	return true
}
func (t *MonsterTree) checkTransition_Idle() bool {
	// Trigger: TriggerOnStateSucceeded
	if t.LastCompletedState != "Patrol" || t.LastStatus != StatusSucceeded {
		return false
	}

	// Conditions

	// Can Select Target
	if !t.canSelectState("Idle") {
		return false
	}

	// Set Transition
	t.NextTransition = &Transition{
		target:   "Idle",
		priority: PriorityNormal,
	}
	return true
}
func (t *MonsterTree) checkTransition_Chase() bool {
	// Trigger: TriggerOnEvent
	if t.PendingEvent != "EnemySpotted" {
		return false
	}

	// Conditions
	if !(&enemyNearbyCondition{}).Test(t.Context) {
		return false
	}

	// Can Select Target
	if !t.canSelectState("Chase") {
		return false
	}

	// Set Transition
	t.NextTransition = &Transition{
		target:   "Chase",
		priority: PriorityHigh,
	}
	return true
}

func (t *MonsterTree) canSelectState(target StateID) bool {
	switch target {
	case "Root":
		return true
	case "Idle":
		return true
	case "Patrol":
		return true
	case "Chase":
		return true
	}
	return false
}

func (t *MonsterTree) selectState(target StateID) bool {
	t.Logger.Printf("  Selecting state [%s]", target)
	t.ActiveStates = t.ActiveStates[:0]

	// Build path (hardcoded per target)
	switch target {
	case "Root":
		if !t.addToPath_Root() {
			return false
		}

		// Child Selection
		// Behavior: SelectionChildrenInOrder
		if t.canSelectState("Idle") && t.selectState("Idle") {
			return true
		}
		return false
	case "Idle":
		if !t.addToPath_Idle() {
			return false
		}

		// Child Selection
	case "Patrol":
		if !t.addToPath_Patrol() {
			return false
		}

		// Child Selection
	case "Chase":
		if !t.addToPath_Chase() {
			return false
		}

		// Child Selection
	}

	t.CurrentState = target
	return true
}

// Path Selection Methods
func (t *MonsterTree) addToPath_Root() bool {
	// Parent

	// Self
	// Check Enter Conditions

	t.ActiveStates = append(t.ActiveStates, "Root")
	return true
}
func (t *MonsterTree) addToPath_Idle() bool {
	// Parent
	if !t.addToPath_Root() {
		return false
	}

	// Self
	// Check Enter Conditions

	t.ActiveStates = append(t.ActiveStates, "Idle")
	return true
}
func (t *MonsterTree) addToPath_Patrol() bool {
	// Parent
	if !t.addToPath_Root() {
		return false
	}

	// Self
	// Check Enter Conditions

	t.ActiveStates = append(t.ActiveStates, "Patrol")
	return true
}
func (t *MonsterTree) addToPath_Chase() bool {
	// Parent
	if !t.addToPath_Root() {
		return false
	}

	// Self
	// Check Enter Conditions

	t.ActiveStates = append(t.ActiveStates, "Chase")
	return true
}

func (t *MonsterTree) Start(startState StateID) error {
	t.Logger.Printf("=== StateTree Starting ===")
	if !t.selectState(startState) {
		return fmt.Errorf("failed to select start state %s", startState)
	}
	// Enter all initial states
	for _, id := range t.ActiveStates {
		t.enterNode(id)
	}
	return nil
}

func (t *MonsterTree) Stop() {
	t.Logger.Printf("=== StateTree Stopping ===")
	for i := len(t.ActiveStates) - 1; i >= 0; i-- {
		t.exitNode(t.ActiveStates[i])
	}
	t.ActiveStates = t.ActiveStates[:0]
}

func (t *MonsterTree) enterNode(stateID StateID) {
	t.Logger.Printf("• Entering state [%s]", stateID)
	switch stateID {
	case "Root":
	case "Idle":
		t.Task_Idle_0.EnterState(t.Context)
	case "Patrol":
		t.Task_Patrol_0.EnterState(t.Context)
	case "Chase":
	}
}

func (t *MonsterTree) exitNode(stateID StateID) {
	t.Logger.Printf("  Exiting state [%s]", stateID)
	switch stateID {
	case "Root":
	case "Idle":
		t.Task_Idle_0.ExitState(t.Context)
	case "Patrol":
		t.Task_Patrol_0.ExitState(t.Context)
	case "Chase":
	}
}
